services:
  wizarr:
    container_name: wizarr
    image: ghcr.io/wizarrrr/wizarr:v2025.11.3
    ports:
      - 5690:5690
    volumes:
      - ${INSTALL_DIRECTORY}/config/wizarr:/data
    environment:
      - PUID=${PUID} #Set UID
      - PGID=${PGID} #Set GID
      - DISABLE_BUILTIN_AUTH=false #Set to true ONLY if you are using another auth provider (Authelia, Authentik, etc)
      - TZ=${TZ} #Set your timezone here
    networks:
      - yams_network
  # jellyfin is used to serve your media to the client devices
  jellyfin:
    image: lscr.io/linuxserver/jellyfin:10.11.4ubu2404-ls10
    container_name: jellyfin
    group_add:
      - '992'
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - VERSION=docker
    devices:
      - /dev/dri/renderD128:/dev/dri/renderD128 # for hardware acceleration
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - ${MEDIA_DIRECTORY}:/data
      - ${INSTALL_DIRECTORY}/config/${MEDIA_SERVICE}:/config
    ports: # plex
      - 8096:8096 # plex
    networks:
      - yams_network
    restart: unless-stopped
  cleanuparr:
    image: ghcr.io/cleanuparr/cleanuparr:latest
    container_name: cleanuparr
    restart: unless-stopped
    networks:
      yams_network:
        ipv4_address: 172.20.0.28
    ports:
      - "11011:11011"
    volumes:
      - ${INSTALL_DIRECTORY}/config/cleanuparr:/config
      # Mount your downloads directory if needed
      - ${MEDIA_DIRECTORY}:/downloads
    environment:
      - PORT=11011
      - BASE_PATH=
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=022
      - TZ=${TZ}

  # Gluetun is our VPN, so you can download torrents safely
  # gluetun:
  #   image: qmcgaw/gluetun:v3.40.3
  #   container_name: gluetun
  #   cap_add:
  #     - NET_ADMIN
  #   devices:
  #     - /dev/net/tun:/dev/net/tun
  #   ports:
  #     - 8888:8888/tcp  # HTTP proxy
  #     - 8388:8388/tcp  #Shadowsocks
  #     - 8388:8388/udp  #Shadowsocks
  #     - 8003:8000/tcp  #Admin
  #     - 8081:8081/tcp  #gluetun
  #     - 8082:8080/tcp  #gluetun
  #   environment:
  #     - VPN_SERVICE_PROVIDER=${VPN_SERVICE}
  #     - VPN_TYPE=wireguard
  #     - WIREGUARD_PRIVATE_KEY=${WIREGUARD_PRIVATE_KEY}
  #     - VPN_PORT_FORWARDING=on
  #     - VPN_PORT_FORWARDING_PROVIDER=protonvpn
  #     - PORT_FORWARD_ONLY=on
  #     - FIREWALL_OUTBOUND_SUBNETS=172.20.0.0/24
  #     - SERVER_COUNTRIES=Netherlands
  #   restart: unless-stopped
  #   networks:
  #     yams_network:
  #       ipv4_address: 172.20.0.18

  # sabnzbd:
  #   image: lscr.io/linuxserver/sabnzbd:4.5.5-ls238
  #   container_name: sabnzbd
  #   environment:
  #     - PUID=${PUID}
  #     - PGID=${PGID}
  #     - TZ=Europe/Paris
  #   volumes:
  #     - /etc/localtime:/etc/localtime:ro
  #     - ${MEDIA_DIRECTORY}:/data
  #     - ${INSTALL_DIRECTORY}/config/sabnzbd:/config
  #   restart: unless-stopped
  #   network_mode: "service:gluetun"

  # qBitorrent is used to download torrents
  # qbittorrent:
  #   image: lscr.io/linuxserver/qbittorrent:4.6.3
  #   container_name: qbittorrent
  #   environment:
  #     - PUID=${PUID}
  #     - PGID=${PGID}
  #     - WEBUI_PORT=8081
  #     - DOCKER_MODS=ghcr.io/vuetorrent/vuetorrent-lsio-mod:latest
  #   volumes:
  #     - /etc/localtime:/etc/localtime:ro
  #     - ${MEDIA_DIRECTORY}:/data
  #     - ${INSTALL_DIRECTORY}/config/qbittorrent:/config
  #   restart: unless-stopped
  #   network_mode: "service:gluetun"

  # Sonarr is used to query, add downloads to the download queue and index TV shows
  # https://sonarr.tv/
  # sonarr:
  #   image: lscr.io/linuxserver/sonarr:4.0.16.2944-ls299
  #   container_name: sonarr
  #   environment:
  #     - PUID=${PUID}
  #     - PGID=${PGID}
  #   volumes:
  #     - /etc/localtime:/etc/localtime:ro
  #     - ${MEDIA_DIRECTORY}:/data
  #     - ${INSTALL_DIRECTORY}/config/sonarr:/config
  #   ports:
  #     - 8989:8989
  #   restart: unless-stopped
  #   networks:
  #     yams_network:
  #       ipv4_address: 172.20.0.13


  jellysearch:
    image: domistyle/jellysearch:latest
    container_name: jellysearch
    restart: unless-stopped
    volumes:
      - ${INSTALL_DIRECTORY}/config/jellyfin/data:/config:ro
    environment:
      MEILI_MASTER_KEY: ${MEILI_MASTER_KEY}
      INDEX_CRON: "0 0 0/2 ? * * *"
      MEILI_URL: "http://meilisearch:7700"
      JELLYFIN_URL: "http://jellyfin:8096"
    networks:
      yams_network:
        ipv4_address: 172.20.0.19


  meilisearch:
    image: getmeili/meilisearch:v1.9
    restart: unless-stopped
    networks:
      yams_network:
        ipv4_address: 172.20.0.21
    volumes:
      - ${INSTALL_DIRECTORY}/config/meili_data:/meili_data
    environment:
      MEILI_MASTER_KEY: ${MEILI_MASTER_KEY}

  # # Radarr is used to query, add downloads to the download queue and index Movies
  # # https://radarr.video/
  # radarr:
  #   image: lscr.io/linuxserver/radarr:6.0.4.10291-ls288
  #   container_name: radarr
  #   environment:
  #     - PUID=${PUID}
  #     - PGID=${PGID}
  #   volumes:
  #     - /etc/localtime:/etc/localtime:ro
  #     - ${MEDIA_DIRECTORY}:/data
  #     - ${INSTALL_DIRECTORY}/config/radarr:/config
  #   ports:
  #     - 7878:7878
  #   restart: unless-stopped
  #   networks:
  #     yams_network:
  #       ipv4_address: 172.20.0.14


  # Bazarr is used to download and categorize subtitles
  # https://www.bazarr.media/
  # bazarr:
  #   image: lscr.io/linuxserver/bazarr:v1.5.3-ls325
  #   container_name: bazarr
  #   environment:
  #     - PUID=${PUID}
  #     - PGID=${PGID}
  #   volumes:
  #     - /etc/localtime:/etc/localtime:ro
  #     - ${MEDIA_DIRECTORY}:/data
  #     - ${INSTALL_DIRECTORY}/config/bazarr:/config
  #   ports:
  #     - 6767:6767
  #   restart: unless-stopped
  #   networks:
  #     yams_network:
  #       ipv4_address: 172.20.0.16

  # profilarr:
  #   image: santiagosayshey/profilarr:beta
  #   container_name: profilarr
  #   volumes:
  #       - ${INSTALL_DIRECTORY}/config/profilarr:/config # Replace with your actual path
  #   ports:
  #     - 6868:6868
  #   environment:
  #       - TZ=Europe/Paris
  #   restart: unless-stopped


  qbitmanage:
    container_name: qbitmanage
    image: ghcr.io/stuffanthings/qbit_manage:v4.6.5
    volumes:
      - ${MEDIA_DIRECTORY}:/data # give qBitManage access to our torrents
      - ${INSTALL_DIRECTORY}/config/qbitmanage:/config # mount our config file (we will create next) into the container
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - QBIT_USER=${QBIT_USER} # allow qBitManage to communicate with qBitTorrent's API
      - QBIT_PASS=${QBIT_PASS}
      - QBT_WEB_SERVER=false # disable the web UI and API. We can manage this with just a config file!
      - QBT_CONFIG_DIR=/config # Ensure qBitManage can find our mounted config file
      - QBT_SCHEDULE=180 # run the process every 180 minutes
      - QBT_STARTUP_DELAY=15 # wait 15 seconds after startup before running, to ensure qBitTorrent is up as well!s
      - QBT_TAG_NOHARDLINKS=true # tag files without hardlinks
      - QBT_SHARE_LIMITS=true # apply share limits to files without hardlinks
      - QBT_DRY_RUN=false

  # Prowlarr is our torrent indexer/searcher. Sonarr/Radarr use Prowlarr as a source
  # https://prowlarr.com/
  # prowlarr:
  #   image: lscr.io/linuxserver/prowlarr:2.3.0.5236-ls133
  #   container_name: prowlarr
  #   ports:
  #      - 9696:9696
  #   environment:
  #     - PUID=${PUID}
  #     - PGID=${PGID}
  #   volumes:
  #     - /etc/localtime:/etc/localtime:ro
  #     - ${INSTALL_DIRECTORY}/config/prowlarr:/config
  #   restart: unless-stopped
  #   networks:
  #     yams_network:
  #       ipv4_address: 172.20.0.17
  #   dns:
  #     - 1.1.1.1
  #     - 1.0.0.1


  jellyseerr:
    image: seerr/seerr:develop
    init: true
    container_name: jellyseerr
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - LOG_LEVEL=debug
      - TZ=Europe/Paris
    ports:
      - 5055:5055
    volumes:
      - ${INSTALL_DIRECTORY}/config/jellyseer:/app/config
    healthcheck:
      test: wget --no-verbose --tries=1 --spider http://localhost:5055/api/v1/status || exit 1
      start_period: 20s
      timeout: 3s
      interval: 15s
      retries: 3
    restart: unless-stopped
    dns:
      - 1.1.1.1
      - 1.0.0.1
    networks:
      yams_network:
        ipv4_address: 172.20.0.25


  # flaresolverr:
  #   # DockerHub mirror flaresolverr/flaresolverr:latest
  #   image: ghcr.io/flaresolverr/flaresolverr:v3.4.6
  #   container_name: flaresolverr
  #   environment:
  #     - LOG_LEVEL=${LOG_LEVEL:-info}
  #     - LOG_FILE=${LOG_FILE:-none}
  #     - LOG_HTML=${LOG_HTML:-false}
  #     - CAPTCHA_SOLVER=${CAPTCHA_SOLVER:-none}
  #     - TZ=Europe/London
  #   volumes:
  #     - ${INSTALL_DIRECTORY}/config/flaresolver:/config
  #   restart: unless-stopped
  #   networks:
  #       yams_network:
  #         ipv4_address: 172.20.0.26
  #   dns:
  #     - 1.1.1.1
  #     - 1.0.0.1

  tunnel:
    image: cloudflare/cloudflared:2025.11.1
    container_name: cloudflared
    restart: unless-stopped
    command: tunnel run
    environment:
      - TUNNEL_TOKEN=${CLOUDFLARE_TUNNEL_TOKEN} # Add to .env
    networks:
      - yams_network

  homeassistant:
    container_name: homeassistant
    image: "ghcr.io/home-assistant/home-assistant:2025.11.3"
    volumes:
      - ./config/homeassistant:/config
      - /etc/localtime:/etc/localtime:ro
      - /run/dbus:/run/dbus:ro
    devices:
      - /dev/ttyUSB0:/dev/ttyUSB0
    cap_add:
    - NET_ADMIN
    - NET_RAW
    restart: unless-stopped
    network_mode: host
    privileged: true
    dns:
      - 1.1.1.1
      - 1.0.0.1
    environment:
      TZ: Europe/Paris

  ha-linky:
    build:
      context: ./ha-linky
      dockerfile: standalone.Dockerfile
    container_name: ha-linky
    depends_on:
      - homeassistant
    restart: unless-stopped
    environment:
      - SUPERVISOR_TOKEN=${SUPERVISOR_TOKEN}
      - WS_URL=ws://192.168.1.40:8123/api/websocket
      - TZ=Europe/Paris
    volumes:
      - ${INSTALL_DIRECTORY}/config/ha-linky:/data
    networks:
      yams_network:
        ipv4_address: 172.20.0.27

  ollama:
    image: ollama/ollama:0.13.0
    container_name: ollama
    restart: unless-stopped
    devices:
      - /dev/dri:/dev/dri
    ports:
      - "11434:11434"
    environment:
      - OLLAMA_NUM_THREADS=2
      - OLLAMA_KEEP_ALIVE=0
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
    volumes:
      # Persistent storage for downloaded models
      - ${INSTALL_DIRECTORY}/config/ollama:/root/.ollama
    networks:
      yams_network:
        ipv4_address: 172.20.0.50 # Fixed IP for stability

  # Open WebUI: The ChatGPT-like Interface
  # open-webui:
  #   image: ghcr.io/open-webui/open-webui:v0.6.40
  #   container_name: open-webui
  #   restart: unless-stopped
  #   ports:
  #     - "8083:8080"
  #   volumes:
  #     - ${INSTALL_DIRECTORY}/config/open-webui:/app/backend/data
  #   environment:
  #     # Connects to the Ollama container internally
  #     - OLLAMA_BASE_URL=http://ollama:11434
  #     - WEBUI_AUTH=true
  #   networks:
  #     yams_network:
  #       ipv4_address: 172.20.0.51

  # Portainer helps debugging and monitors the containers
  portainer:
    image: portainer/portainer-ce:2.33.5-alpine
    container_name: portainer
    ports:
      - 9000:9000
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ${INSTALL_DIRECTORY}/config/portainer:/data
    restart: unless-stopped
    networks:
      yams_network:
        ipv4_address: 172.20.0.23

  beszel:
    image: 'henrygd/beszel:0.16'
    container_name: beszel
    restart: unless-stopped
    networks:
      yams_network:
        ipv4_address: 172.20.0.30
    volumes:
      - ${INSTALL_DIRECTORY}/config/beszel_data:/beszel_data
      - ${INSTALL_DIRECTORY}/config/beszel_socket:/beszel_socket
    ports:
      - "8090:8090"


  beszel-agent:
    image: henrygd/beszel-agent-intel:0.16
    container_name: beszel-agent
    restart: unless-stopped
    network_mode: host
    cap_add:
      - CAP_PERFMON
      - SYS_RAWIO # required for S.M.A.R.T. data
      - SYS_ADMIN # required for NVMe S.M.A.R.T. data
    devices:
      - /dev/dri/card0:/dev/dri/card0
      - /dev/sda:/dev/sda
      - /dev/nvme0:/dev/nvme0
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ${INSTALL_DIRECTORY}/config/beszel_agent_data:/var/lib/beszel-agent
      # monitor other disks / partitions by mounting a folder in /extra-filesystems
      - /:/extra/filesystem:ro
      - ${INSTALL_DIRECTORY}/config/beszel_socket:/beszel_socket
      - /var/run/dbus/system_bus_socket:/var/run/dbus/system_bus_socket:ro
      - /srv/media/.beszel:/extra-filesystems/sda__Media:ro
    environment:
      LISTEN: /beszel_socket/beszel.sock
      KEY: ${BESZEL_KEY}
      TOKEN: ${BESZEL_TOKEN}
      HUB_URL: http://192.168.1.40:8090
  postgres:
    image: postgres:16
    restart: always
    networks:
      yams_network:
        ipv4_address: 172.20.0.41
    environment:
      - POSTGRES_USER
      - POSTGRES_PASSWORD
      - POSTGRES_DB
      - POSTGRES_NON_ROOT_USER
      - POSTGRES_NON_ROOT_PASSWORD
    volumes:
      - ${INSTALL_DIRECTORY}/config/postgres/db:/var/lib/postgresql/data
      - ${INSTALL_DIRECTORY}/config/postgres/init-data.sh:/docker-entrypoint-initdb.d/init-data.sh
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -h localhost -U ${POSTGRES_USER} -d ${POSTGRES_DB}']
      interval: 5s
      timeout: 5s
      retries: 10

  n8n:
    image: docker.n8n.io/n8nio/n8n:1.123.0
    restart: always
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}
      - DB_POSTGRESDB_USER=${POSTGRES_NON_ROOT_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_NON_ROOT_PASSWORD}
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - N8N_RUNNERS_ENABLED=true
    links:
      - postgres
    volumes:
      - ${INSTALL_DIRECTORY}/config/n8n:/home/node/.n8n
    networks:
      yams_network:
        ipv4_address: 172.20.0.40
    depends_on:
      postgres:
        condition: service_healthy
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.n8n.rule=Host(`n8n.erwanleboucher.dev`)"
      - "traefik.http.routers.n8n.entrypoints=websecure"
      - "traefik.http.routers.n8n.tls.certresolver=myresolver"
      - "traefik.http.services.n8n.loadbalancer.server.port=5678"

  # Watchtower is going to keep our instances updated
  watchtower:
    image: nickfedor/watchtower:1.12.3
    container_name: watchtower
    environment:
      - WATCHTOWER_CLEANUP=true
      - WATCHTOWER_SCHEDULE=0 0 4 * * * # Check daily at 4am
      - WATCHTOWER_MONITOR_ONLY=true
      - WATCHTOWER_NOTIFICATIONS=shoutrrr
      - WATCHTOWER_NOTIFICATION_URL=discord://ittcuGYpRo6XP1SyEYZhWv6VUp6AZjtrmu3V_dIUQ9Bp4OqOIAbBPmDyjNh-aLgR7Uvh@1445142964794953910
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    restart: unless-stopped
    networks:
      yams_network:
        ipv4_address: 172.20.0.20
networks:
  yams_network:
    name: yams_network
    ipam:
      config:
        - subnet: 172.20.0.0/24

  default:
    external: true
    name: yams_network
